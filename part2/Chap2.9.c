// 第二章
// 2.9 位运算符
/*
 * C语言提供了6个位操作运算符。
 * 这些位运算符只能作用于整型操作数，即只能作用于带符号或无符号的char、short、int与long类型。
 * & 按位与(AND)
 * | 按位或(OR)
 * ^ 按位异或(XOR)
 * << 左移
 * >> 右移
 * ~ 按位求反(一元运算符)
 *
 * 注意，位运算符&、|和逻辑运算符&&、||的区别。
 * &运算1和2结果为0
 * &&运算1和2结果为1
 *
 * 移位运算符<<与>>分别用于将运算的左操作数左移与右移，移动的位数则由右操作数指定（右操作数
 * 的值必须是非负值）。因此，表达式x<<2将把x的值左移两位，右边空出的2位用0填补，该表达式
 * 等价于对左操作数乘以4。
 * 在对unsigned类型的无符号数右移时，左边空出的2位用0填补；
 * 当对signed类型的带符号数值进行右移时，某些机器将对左边空出的部分以哦那个符号位填补（即“算术移位”），
 * 而另一些机器则对左边空出的部分用0填补（即“逻辑移位”）。
 *
 * ~ 求整数的二进制反码，即分别将操作数各二进制位上的1变为0，0变为1。
 * */

#include <stdio.h>

// 返回x中从第p位开始的n位
unsigned getbits(unsigned x,int p,int n);

int main() {

    printf("&运算1和2结果为%d", 1 & 2);
    printf("\n&&运算1和2结果为%d", 1 && 2);
    // &运算1和2结果为0
    // &&运算1和2结果为1

    // &运算特殊用途    全一为一  负数按补码形式参加按位与运算
    // 1清零。如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。
    // 2取一个数中指定位
    int a = 0b1010110010;// 十进制690
    int b = 0b0000000000;// 1，清零
    int c = 0b0000001111;// 2，取低四位
    printf("\n二进制数a转换为十进制数:%d", a);
    printf("\na & b 结果为:%d", a & b);
    printf("\na & c 结果为:%d", a & c);
    // 输出
  /*二进制数a转换为十进制数:690
    a & b 结果为:0
    a & c 结果为:2     取低四位 0010   2
    */

    // |运算特殊用途    一个为一则为一  负数按补码形式参加按位与运算
    // 1，常用来对一个数据的某些位置1。
    int d = 0b1010110010;// 十进制690
    int e = 0b0000001111;// 1，低四位置为1
    printf("\nd | e 结果为:%d", d | e);
    // d | e 结果为:703  0010变1111，690+8+4+2+1=703

    // ^运算特殊用途    相同为0，不同为1
    // 1，使特定位翻转找一个数，对应X要翻转的各位，该数的对应位为1，其余位为零，此数与X对应位异或即可。
    // 2，与0相异或，保留原值 。X ^ 00000000 = 1010 1110。
    int f = 0b1010110010;// 十进制690
    int g = 0b0000001111;// 1，使f低四位翻转
    printf("\nf ^ g 结果为:%d", f ^ g);
    // f ^ g 结果为:701    0010变为1101，690+8+4-2+1=701

    // <<
    int h = 0b1010110010;// 十进制690
    printf("\nh << 2 结果为:%d", h << 2);
    // h << 2 结果为:2760    1010110010变为101011001000
    int i = 0b10101100100000000000000000000000;
    printf("\ni << 2 结果为:%d", i << 2);
    // i << 2 结果为:-1308622848   此示例溢出

    // >>
    int j = 0b1010110010;// 十进制690
    printf("\nj >> 2 结果为:%d", j >> 2);
    // j >> 2 结果为:172    1010110010变为10101100
    int k = 0b10101100100000000000000000000000;
    printf("\nk >> 2 结果为:%d", i >> 2);
    // k >> 2 结果为:-350224384

    // ~ 求整数的二进制反码，即分别将操作数各二进制位上的1变为0，0变为1。
    // 使一个数的最低位为零，可以表示为：a & ~1
    int l = 0b10;

    unsigned int m = 101010;
    printf("\ngetbits返回结果%d", getbits(m, 2, 3));

    unsigned int n = 10010111;
    printf("\ngetbits返回结果%d", getbits(m, 4, 2));

    // 通过 a^b^b=a，不使用中间变量实现交换两数
    unsigned int num1 = 20;
    unsigned int num2 = 30;
    num1 = num1 ^ num2;
    num2 = num1 ^ num2;
    num1 = num1 ^ num2;
    printf("\n num1:value=%d\n num2:value=%d", num1, num2);
    return 0;
}

// 这里假定最右边的一位是第0位，n与p都是合理的正值。
// 例如getbits（x，4，3）返回x中的第4、3、2三位的值。
unsigned getbits(unsigned x,int p,int n) {
    // x >> (p+1-n)将期望获得的字段移位到字的最右端。
    // ~0的所有位都为1，这里使用语句~0<<n将~0左移n位，并将最右边的n位用0填补。
    // 再使用~运算对它按位取反，这样就建立了最右边全为1的屏蔽码。

    /*
     * eg:
     * 101010
     * 101010 >> 2+1-3  为   101010
     * ~0 << 3  为 111000
     * ~(111000)    为   000111
     * 101010 & 000111  为 010
     * */
    return (x >> (p+1-n) & ~(~0 << n));
}

