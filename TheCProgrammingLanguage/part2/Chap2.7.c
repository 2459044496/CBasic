// 第二章
// 2.7 类型转换
/*
 * 一般来说，自动转换是指把“比较窄的”操作数转换为“比较宽的”操作数，并且不会丢失信息的转换，
 * 例如，在计算表达式 f+i 中，将整型变量 i 的值自动转换为浮点数（这里的变量 f 为浮点型）。
 *
 * 不允许使用无意义的表达式，例如，不允许把float类型的表达式作为下标。
 *
 * 由于char类型就是较小的整型，因此在算术表达式中可以自由使用char类型的变量，
 * 这就为实现某些字符转换提供了很大的灵活性。
 * 比如，下面的函数atoi，它将一串数字转换为相应的数值。
 * 标准头文件<ctype.h>定义了一组与字符集无关的测试和转换函数。
 *
 * 将字符类型转换为整型时，我们需要注意一点。C语言没有指定char类型的变量是
 * 无符号变量（signed）还是带符号变量（unsigned）。
 * 当把一个char类型的值转换为int类型的值时，其结果有没有可能为负整数？
 * 对于不同的机器，其结果也不同，这反映了不同机器结构之间的区别。
 * 为了保证程序的可移植性，如果要在char类型的变量中存储非字符数据，最好
 * 指定signed或unsigned限定符。
 *
 * 当关系表达式（如 i>j ）以及由&&、||连接的逻辑表达式的判定结果为真时，表达式
 * 的值为1；当判定结果为假时，表达式的值为0。
 * 在if、while、for等语句的测试部分中，“真”就意味着“非0”，这二者之间没有区别。
 *
 * 附录A.6节详细地列出了转换规则。
 * 但是，如果没有unsigned类型的操作数，则只要使用下面这些非正式的规则就可以了：
 * 1，如果其中一个操作数的类型为long double，则将另一个操作数转换为long double类型；
 * 2，一个double，则将另一个double；
 * 3，一个float，则将另一个float；
 * 4，将char与short类型的操作数转换为int类型；
 * 5，一个long，则将另一个long；
 * 注意，表达式中float类型的操作数不会自动转换为double类型。
 *
 * 当表达式中包含unsigned类型的操作数时，转换规则要复杂一些。
 * 注意原因在于，带符号值与无符号值之间的运算是与机器相关的，应为它们取决于机器中不同整型类型的大小。
 * 例如，假定int类型占16位，long类型占32位，那么，-1L<1U，这是因为unsigned int类型的
 * 1U将被提升为signed long类型；但-1L>1UL，这是因为-1L将被提升为unsigned long类型，
 * 因而成为一个比较大的正数。
 *
 * 赋值时也要进行类型转换。赋值运算符右边的值需要转换为左边变量的类型，左边变量的类型即
 * 赋值表达式结果的类型。
 *
 * 无论是否进行符号扩展，字符型变量都将被转换为整型变量。
 * 当把较长的整数类型转换为较短的整数或char类型时，超出的高位部分将被丢弃。
 * 因此，下列程序段
 *  int i;
 *  char c;
 *
 *  i = c;
 *  c = i;
 * 执行后，c的值将保持不变。
 * 无论是否进行符号扩展，该结论都成立。但是，如果把两个赋值语句的次序颠倒一下，则
 * 执行后可能会丢失信息。
 *
 * 如果x时float类型，i是int类型，那么语句x=i与i=x在执行时都要进行类型转换，
 * 当把float类型转换为int类型时，小数部分将被截取掉；当把double类型转换为
 * float类型时，是进行四舍五入还是截取取决于具体的实现。
 *
 * 由于函数调用的参数是表达式，所以在把参数传递给函数时也可能进行类型转换。
 * 在没有函数原型的情况下，char与short类型都将被转换为int类型，float类型将被
 * 转换为double类型。因此，即使调用函数的参数为char或float类型，我们也把
 * 函数参数声明为int或double类型。
 *
 * 在任何表达式中都可以使用一个称为强制类型转换的一元运算符强制进行显示类型转换。
 * （类型名）表达式
 * 强制类型转换只是生成一个指定类型的值，本身并没有改变，
 * 强制类型转换与其他一元运算符具有相同的优先级。
 *
 * 在通常情况下，参数是通过函数原型声明的。这样，当函数被调用时，声明将对参数进行自动强制转换。
 * 例如，对于sqrt的函数原型
 * double sqrt(double);
 * 下列函数调用
 * root2 = sqrt(2);
 * 不需要使用强制类型转换运算符就可以自动将整数2强制转换为double类型的值2.0。
 * */

#include <stdio.h>

// 将一串数字转换为相应的数值。
int atoi(char s[]);

// 将char类型转换为int类型，将ASCII字符集中的字符映射到对应的小写字母。
// 如果待转换的字符不是大写字母，lower函数将返回字符本身。
int lower(int c);

int main() {
    char s[] = "823";
    printf("value:%d", atoi(s));
    int c = 65;
    printf("\nvalue:%d", lower(c));

    // 输出
  /*value:823
    value:97
    */
}

int atoi(char s[]) {
    int i;
    int n = 0;

    for (i = 0; s[i] >= '0' && s[i] <= '9'; ++i) {
        n = 10 * n + (s[i] - '0');
    }
    return n;
}

int lower(int c) {
    if (c >= 'A' && c <= 'Z') {
        return c + 'a' - 'A';
    } else {
        return c;
    }
}
